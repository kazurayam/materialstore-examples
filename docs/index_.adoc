= materialstore tutorial

== Links

=== Repository and product

- link:https://github.com/kazurayam/materialstore[materialstore on GitHub]

- link:https://mvnrepository.com/artifact/com.kazurayam/materialstore[Maven Central URL]

=== API documents

- link:https://kazurayam.github.io/materialstore/api/[materialstore Javadoc]

- link:https://kazurayam.github.io/materialstore-mapper/api/[materialstore-mapper Javadoc]

== Introduction

=== Background

Several years ago when I worked for an IT company, I endeavored to develop
automated UI tests for their Web applications.
I studied Selenium WebDriver in Java.
I studied the following article to learn how to take screenshots of web pages.

- https://www.guru99.com/take-screenshot-selenium-webdriver.html[Guru99, How to Take Screenshot in Selenium WebDriver]

I retyped their sample code. Here I will quote the entire source codes.

[source,java]
----
include::../src/test/java/guru99/selenium/screenshot/TakeScreenshotTest.java[]
----

When I ran this, the test produced a PNG image file in the `tmp` directory
under the project's root directory:

[source]
----
:~/github/materialstore-tutorial (master *+)
$ tree ./tmp
./tmp
└── test.png

0 directories, 1 file
----

The `test.png` image looked as this:

image:https://kazurayam.github.io/materialstore-tutorial/images/ch1/test.png[]

The code worked just fine.

=== Problem to solve

Based on the sample code above, I wrote many Selenium tests that take bunches of screenshots.
During the course, I found a few problems in the code shown above.

==== Problem1 I had to repeat writing code to create directories to store files

The Selenium library supports taking a screenshot of browser window
and saving image into a temporary file.
However, Selenium does not provide a mean of organizing the created files.
I had to write codes that create a directory structure to store the PNG files.
I ran a single test many times, and I wanted to preserve the outcomes
of 1st, 2nd and 3rd run.
So I need to create directories with name of timestamp format like
`20220414_093417`, `20220415_163924`, `20220416_170836` and so on.
I repeated inventing directory trees to store PNG files.
It was just tiring and boring.

The link:https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[DRY] principle came up to me.
I wanted to invent a reusable library that manages a directory tree to
store screenshots created by my Selenium tests.

==== Problem2 Metadata of Web page disappeared

By executing the test, I got a file `./tmp/test.png`.
In fact the file was created out of a web page at the URL `http://demo.guru99.com/V4/`.
But the metadata (from which URL it was created,
at which stage of test processing it was created, etc)
is not recorded in the stored file.
Other program may read the file to reuse somehow, but it will never
be informed of the metadata that the `./tmp/test.png` file
was created out of the URL `http://demo.guru99.com/V4/`.

Without the metadata, screenshots are not reusable for any purposes.
Screenshots become garbage as soon as created.

==== Problem3 I had to repeat writing code to view stored files

When I got many PNG files on disk,
naturally I wanted a easy method to view images.
I wrote a code to generate an HTML report of PNG files.
I realised I should make the code as a reusable library.

==== Problem4 I wanted to compare 2 sets of screenshots of a single Web app

I developed a set of tests that take screenshots of web pages of
a single web app with 100% coverage.
Then I wanted to perform *Visual Inspection*:
compare the Development environment vs the Production environment;
compare the pages Before vs After a software update.

I may find unexpected visual differences between the two sets.
The visual inspection report will let me know exactly
which part of my web application needs to be looked at.

However, a program that compares 2 sets of screenshots was difficult to implement.
It required the problem 1, 2 and 3 to be resolved as prerequisite.

=== Solution by Materialstore

==== Terminology

In this document I use a special term "**material**".
A material is a file of which content is downloaded from a URL.
A screenshot of a web page is a typical material.
An HTML source text of a web page can be a material as well.
Any file downloaded from web can be a material
--- `.png`, `.jpg`, `.html`, `.json`, `.xml`, `.txt`, `.csv`, `.js`, `.css`, `.xlsx`, `.pdf` and so on.

==== Sample code

The following code is a JUnit5-based test written in Java.
It performs the following processing:

1. it `https://www.google.com`
2. in the `<input type="text" name="q">` field, type a query string
3. take a screenshot and save the PNG image into the `store` directory.
4. and do SEND; wait for the response
5. take another screenshot and save it into the `store` directory
6. compile an HTML report that renders the 2 PNG files with the metadata (URL etc)

[source,java]
----
include::../src/test/java/com/kazurayam/materialstore/tutorial/ch1/GoogleSearchTest.java[]
----

==== Output directory structure

When I ran the test, it creates a directory named `store` under the
project's directory where a tree of directories/files are created.

----
:~/github/materialstore-tutorial (master *+)
$ tree ./build/tmp/testOutput
./build/tmp/testOutput
└── com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest
    └── store
        ├── GoogleSearch
        │   └── 20220415_224026
        │       ├── index
        │       └── objects
        │           ├── a7a5c13181ccadc1502bd325df2fa43d6a58a5be.png
        │           └── fe165e0a3a4577caa0c5756a526b3fc320e0b64e.png
        └── GoogleSearch-list.html

5 directories, 4 files
----

==== The index file

The `store/GoogleSearch/yyyyMMdd_hhmmss/index` file would be interesting.
Its content is something like this:

[source]
----
include::testOutput/com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest/store/GoogleSearch/20220415_224848/index[]
----

Points to note:

1. The `index` file contains a sequence of lines which comprises with 3 parts:
_ID, _FileType_ and _Metadata_. The 3 parts are delimited by tabs. The `index` file
is encoded with UTF-8.
2. A single line in the `index` file corresponds to a single physical file
in the `objects` subdirectory.
3. The name of physical files in the `objects` subdirectory has a standard format,
that is 40 characters of hex-decimal string followed by a dot "." and ends with a FileType extension.
4. The 40 characters (`ID` for short) are the SHA1 digital signature
derived from the content byte array of each file.
5. In the Materialstore world, you, programmer/tester, are no longer responsible for naming each physical files.
6. Each line in `index` file contains the *Metadata*: the URL out of which screenshots are taken, and the fact that I made a query for "Shohei Ohtani" to Google.
7. What type of data can I put in the *Metadata*? --- quite flexible.
You can put any pair of Strings. The API supports a shortcut method to
add a URL into Metadata because URL is most frequently used as Metadata.
8. The *Metadata* of each line in `index` MUST be unique in a `index` file.
An attempt to write an object into the store with
duplicating *Metadata* with already stored object will be fail.
You, programmer/tester, are asked to assign descriptive enough
*Metadata* to each object.

==== Report generated

The test generated a HTML like this:

- link:testOutput/com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest/store/GoogleSearch-list.html[]

image:images/ch1/GoogleSearch-html.png[]

The materialstore library makes it easy for me to
store the materials (files downloaded from URLs) on to disk,
and reuse them for later reuse.


