= materialstore tutorial

== Links

=== Repository and product

- link:https://github.com/kazurayam/materialstore[materialstore on GitHub]

- link:https://mvnrepository.com/artifact/com.kazurayam/materialstore[Maven Central URL]

=== API documents

- link:https://kazurayam.github.io/materialstore/api/[materialstore Javadoc]

- link:https://kazurayam.github.io/materialstore-mapper/api/[materialstore-mapper Javadoc]

== Introduction

=== Background

Several years ago when I worked for an IT company, I endeavored to develop
automated UI tests for their Web applications.
I studied Selenium WebDriver in Java.
I studied the following article to learn how to take screenshots of web pages.

- https://www.guru99.com/take-screenshot-selenium-webdriver.html[Guru99, How to Take Screenshot in Selenium WebDriver]

I retyped their sample code. Here I will quote the entire source codes.

[source,java]
----
include::../src/test/java/guru99/selenium/screenshot/TakeScreenshotTest.java[]
----

When I ran this, the test produced a PNG image file in the `tmp` directory
under the project's root directory:

[source]
----
:~/github/materialstore-tutorial (master *+)
$ tree ./tmp
./tmp
└── test.png

0 directories, 1 file
----

The `test.png` image looked as this:

image:https://kazurayam.github.io/materialstore-tutorial/images/ch1/test.png[]

The code worked just fine.

=== Problem to solve

Based on the sample code above, I wrote many Selenium tests that take bunches of screenshots.
During the course, I found a few problems in the code shown above.

==== Problem1 Shouldn't repeat inventing directory structures

The Selenium library supports taking a screenshot of browser window
and saving image into a temporary file.
However, Selenium does not provide a mean of organizing the created files.
I had to write codes that create a directory structure to store the PNG files.
I ran a single test many times, and I wanted to preserve the outcomes
of 1st, 2nd and 3rd run.
So I need to create directories with name of timestamp format like
`20220414_093417`, `20220415_163924`, `20220416_170836` and so on.
I repeated inventing directory trees to store PNG files.
It was just tiring and boring.

The link:https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[DRY] principle came up to me.
I wanted to invent a reusable library that manages a directory tree to
store screenshots created by my Selenium tests.

==== Problem2 Metadata of Web page disappeared

By executing the test, I got a file `./tmp/test.png`.
In fact the file was created out of a web page at the URL `http://demo.guru99.com/V4/`.
But the metadata (from which URL it was created,
at which stage of test processing it was created, etc)
is not recorded in the stored file.
Other program may read the file to reuse somehow, but it will never
be informed of the metadata that the `./tmp/test.png` file
was created out of the URL `http://demo.guru99.com/V4/`.

Without the metadata, screenshots are not reusable for any purposes.
Screenshots become garbage as soon as created.

==== Problem3 Shouldn't repeat writing code for reporting

When I got many PNG files on disk,
naturally I wanted a easy method to view images.
I wrote a code to generate an HTML report of PNG files.
I realised I should make the code as a reusable library.

==== Problem4 Want to perform Visual Inspection

I developed a set of tests that take screenshots of web pages of
a single web app with 100% coverage.
Then I wanted to perform *Visual Inspection*:
compare the Development environment vs the Production environment;
compare the pages Before vs After a software update.

I may find unexpected visual differences between the two sets.
The visual inspection report will let me know exactly
which part of my web application needs to be looked at.

However, a program that compares 2 sets of screenshots was difficult to implement.
It required the problem 1, 2 and 3 to be resolved as prerequisite.

=== Solution by Materialstore

I will describe how the Materialstore library solves the problem1, 2 and 3.
I will describe the solution to the problem 4 later in another section.

==== Terminology

In this document I use a special term "**material**".
A material is a file of which content is downloaded from a URL.
A screenshot of a web page is a typical material.
An HTML source text of a web page can be a material as well.
Any file downloaded from web can be a material
--- `.png`, `.jpg`, `.html`, `.json`, `.xml`, `.txt`, `.csv`, `.js`, `.css`, `.xlsx`, `.pdf` and so on.

==== The Sample code

The following code is a JUnit5-based test written in Java.
It performs the following processing:

1. it `https://www.google.com`
2. in the `<input type="text" name="q">` field, type a query string
3. take a screenshot and save the PNG image into the `store` directory.
4. and push SEND key; wait for the response
5. once the Search Result page is shown, take another screenshot and save it into the `store` directory
6. compile an HTML report that renders the 2 materials (screenshots in PNG).
7. the report will show metadata of the materials, such as URL of web pages.

[source,java]
----
include::../src/test/java/com/kazurayam/materialstore/tutorial/ch1/GoogleSearchTest.java[]
----

==== Output directory structure

When I ran the test, it creates a directory named `store` under the
project's directory where a tree of directories/files are created.

----
:~/github/materialstore-tutorial (master *+)
$ tree ./build/tmp/testOutput
./build/tmp/testOutput
└── com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest
    └── store
        ├── GoogleSearch
        │   └── 20220415_224026
        │       ├── index
        │       └── objects
        │           ├── a7a5c13181ccadc1502bd325df2fa43d6a58a5be.png
        │           └── fe165e0a3a4577caa0c5756a526b3fc320e0b64e.png
        └── GoogleSearch-list.html

5 directories, 4 files
----

The `com.kazurayam.materialstore.filesystem.Store` class manages this directory tree.
The directory tree has the following structure.

1. The `Store` object saves everything under a single root directory which is usually named as `store`.
2. Under the `store` directory there will be one or more _JobName_ directories, such as `GoogleSearc`.
3. Under a _JobName_ directory there will be one or more _JobTimestamp_ directories, such as `20220415_224026`.
4. Under a _JobTimestamp_ directory there is a file named `index`.
5. Under a _JobTimestamp_ directory there is a directory named `objects`.
6. Under a `objects` directory there will be one or more _object_ files.
7. An _object_ file has a physical file name in the format of 40 Hex-decimal characters followed by a dot `.` and
file extension, such as `a7a5c13181ccadc1502bd325df2fa43d6a58a5be.png`.
8. The _object_ files are stored flat in the `objects` directory. There will be no sub-directory under the `objects` directory.

As you see, the **problem1 (Directory structure)** is resolved by the `Store`.

==== The index file

The `store/GoogleSearch/yyyyMMdd_hhmmss/index` file would be interesting.
Its content is something like this:

[source]
----
include::testOutput/com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest/store/GoogleSearch/20220415_224848/index[]
----

Points to note :

1. The `index` file contains a sequence of lines. Each line comprises with 3 parts:
_ID, _FileType_ and _Metadata_. The 3 parts are delimited by tabs. The `index` file
is encoded with UTF-8.
2. A single line in the `index` file corresponds to a single physical file
in the `objects` subdirectory.
3. The name of physical files in the `objects` subdirectory has a standard format,
that is 40 characters of hex-decimal string followed by a dot "." and ends with a FileType extension.
4. The 40 characters (`ID` for short) are the SHA1 digital signature
derived from the content byte array of each file.
5. In the Materialstore world, you (a programmer or a tester) are no longer responsible for naming each physical files.
6. Each line in `index` file contains the *Metadata*: the URL out of which screenshots are taken, and the fact that I made a query for "Shohei Ohtani" to Google.
7. What type of data can I put in the *Metadata*? --- quite flexible.
You can put any pair of Strings. The API supports a shortcut method to
add a URL into Metadata because URL is most frequently used as Metadata.
8. The *Metadata* of each line in `index` MUST be unique in a `index` file.
An attempt to write an object into the store with
duplicating *Metadata* with already stored object will be fail.
You, programmer/tester, are asked to assign descriptive enough
*Metadata* to each object.
9. The `com.kazurayam.materialstore.filesystem.Store` class implements
`write` methods to store files into the store,
and `select` methods to retrieve materials out of the store.
See the javadoc of
link:https://kazurayam.github.io/materialstore/api/com/kazurayam/materialstore/filesystem/Store.html[Store] class.
10. See the javadoc of
link:https://kazurayam.github.io/materialstore/api/com/kazurayam/materialstore/filesystem/FileType.html[FileType] for the full list of supported FileTypes.

As you see, the **problem2 (Metadata)* is resolved by the `Store`.

==== Report generated

The test generated a HTML like this:

- link:testOutput/com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest/store/GoogleSearch-list.html[]

image:images/ch1/GoogleSearch-html.png[]

As you see, the **problem3 (Report)** is resolved by the `Inspector`.



