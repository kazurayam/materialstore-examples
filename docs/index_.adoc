= materialstore tutorial

== Links

=== Repository and product

- link:https://github.com/kazurayam/materialstore[materialstore on GitHub]

- link:https://mvnrepository.com/artifact/com.kazurayam/materialstore[Maven Central URL]

=== API documents

- link:https://kazurayam.github.io/materialstore/api/[materialstore Javadoc]

- link:https://kazurayam.github.io/materialstore-mapper/api/[materialstore-mapper Javadoc]

== Introduction

=== Background

Several years ago when I worked for an IT company, I endeavored to develop
automated UI tests for their Web applications.
I studied Selenium WebDriver in Java.
I studied the following article to learn how to take screenshots of web pages.

- https://www.guru99.com/take-screenshot-selenium-webdriver.html[Guru99, How to Take Screenshot in Selenium WebDriver]

I retyped their sample code. Here I will quote the entire source codes.

[source,java]
----
include::../src/test/java/guru99/selenium/screenshot/TakeScreenshotTest.java[]
----

When I ran this, the test produced a PNG image file in the `tmp` directory
under the project's root directory:

[source]
----
:~/github/materialstore-tutorial (master *+)
$ tree ./tmp
./tmp
└── test.png

0 directories, 1 file
----

The `test.png` image looked as this:

image:https://kazurayam.github.io/materialstore-tutorial/images/ch1/test.png[]

The code worked just fine.

=== Problem to solve

I wrote many Selenium tests that take bunches of screenshots.
During the course, I found several problems in the code shown above.

==== Problem1 I had to repeat writing code to create directories to store files

The Selenium library supports taking a screenshot of browser window
and saving image into a temporary file.
However, Selenium does not provide a mean of organizing the created files.
I had to write codes that create a directory structure to store the PNG files.

I ran a single test many times, and I wanted to preserve the outcomes
of 1st, 2nd and 3rd run.
So I need to create directories with name of timestamp format like
`20220414_093417`, `20220415_163924`, `20220416_170836` and so on.
I repeated inventing directory trees to store PNG files.
It was just tiring and boring.

The link:https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[DRY] principle came up to me.
I wanted to invent a reusable library that manages a directory tree to
store screenshots created by my Selenium tests.

==== Problem2 Metadata of Web page disappeared

By executing the test, I got a file `./tmp/test.png`.
In fact the file was created out of a web page at the URL `http://demo.guru99.com/V4/`.
But the metadata (from which URL it was created,
at which stage of test processing it was created, etc)
is not recorded in the stored file.
Other program may read the file to reuse somehow, but it will never
be informed of the metadata that the `./tmp/test.png` file
was created out of the URL `http://demo.guru99.com/V4/`.

Without the metadata, screenshots are not reusable for any purposes.
Screenshots become garbage as soon as created.

==== Problem3 I had to repeat writing code to view stored files

When I got many PNG files on disk,
naturally I wanted a easy method to view images.
I wrote a code to generate an HTML report of PNG files.
I realised I should make the code as a reusable library.

==== Problem4 I wanted to compare 2 sets of screenshots of a single Web app

I developed a set of tests that take screenshots of web pages of
a single web app with 100% coverage.
Then I wanted to perform *Visual Inspection*:
compare the Development environment vs the Production environment;
compare the pages Before vs After a software update.

Sometimes I find unexpected visual differences between the two sets.
The report of comparison becomes the best checklist for me
to improve the quality of software.

=== Solution by Materialstore

==== Terminology

In this document I use a special term "**material**".
A material is a file of which content is downloaded from a URL.
A \*.png image file as screenshot of a web page rendered in browser
is a typical material.
An HTML source text of a web page can be a material as well.
Anything downloaded from web can be a material
--- \*.json, \*.xml,\*.txt, \*.csv, \*.js, \*.css, \*.xlsx, \*.pdf and so on.
I would call these files managed by the materialstore library as "materials".

==== Sample code

The following code is a JUnit5-based test in Java,
which performs the following:

1. it opens Chrome browser, navigates to `https://www.google.com`
2. in the `<input type="text" name="q">` field, type a query string, take a screenshot and save the PNG image into the `store` directory.
3. and do SEND; wait for the respnse; take anothr screenshot and save it into the `store` directory
4. compile a HTML report that renders the 2 PNG files with the metadata (URL etc)


[source,java]
----
include::../src/test/java/com/kazurayam/materialstore/tutorial/ch1/GoogleSearchTest.java[]
----
<1> we use WebDriverManager to control ChromeDriver version
<2> create a directory to write outputs from this test class
<3> create the `store` directory where all of downloaded materials are stored
<4> prepare an instance of `com.kazurayam.materialstore.filesystem.Store` class which manages writing/reading materials
<5> specify the names of directories under the "store" directory
<6> open Chrome browser
<7> open the Google Search page
<8> set a query string into the <input name="q"> element
<9> take a screenshot of the Google Search page
<10> save the image into the store

When I ran the test, it creates a directory named `store` under the
project's directory where a tree of directories/files are created.

----
:~/github/materialstore-tutorial (master *+)
$ tree ./build/tmp/testOutput
./build/tmp/testOutput
└── com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest
    └── store
        ├── GoogleSearch
        │   └── 20220415_224026
        │       ├── index
        │       └── objects
        │           ├── a7a5c13181ccadc1502bd325df2fa43d6a58a5be.png
        │           └── fe165e0a3a4577caa0c5756a526b3fc320e0b64e.png
        └── GoogleSearch-list.html

5 directories, 4 files
----

The `store/GoogleSearch/yyyyMMdd_hhmmss/index` file would be interesting.
Its content is something like this:

[source]
----
include::testOutput/com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest/store/GoogleSearch/20220415_224848/index[]
----

Points to note:

1. Physical files has a standard naming convention: 40 characters of hex-decimal string
followed by a dot ".", ends with a FileType extension such as `.png`.
The 40 characters (`ID` for short) are the SHA1 digital signature
derived from the content byte array of each file.
2. In the Materialstore world, you, programmer/tester, are no longer responsible for naming each physical files.
3. Each line in `index` file contains the *Metadata*: the URL out of which
screenshots are taken, and the fact that I made a query for "Shohei Ohtani" to Google.
4. What type of data can I put in the *Metadata*? --- quite flexible.
You can put any pair of Strings. The API supports a shortcut method to
add a URL into Metadata because URL is most frequently used as Metadata.
5. The *Metadata* of each line in `index` MUST be unique in a `index` file.
An attempt to write an object into the store with
duplicating *Metadata* with already stored object will be fail.
You, programmer/tester, are asked to assign descriptive enough
*Metadata* to each object.

The test generated a HTML like this:

- link:testOutput/com.kazurayam.materialstore.tutorial.ch1.GoogleSearchTest/store/GoogleSearch-list.html[]

image:images/ch1/GoogleSearch-html.png[]


